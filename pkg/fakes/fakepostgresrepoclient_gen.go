// Code generated by counterfeiter. DO NOT EDIT.
package fakes

import (
	"context"
	"net/http"
	"sync"

	"github.com/render-oss/render-mcp-server/pkg/client"
)

type FakePostgresRepoClient struct {
	CreatePostgresWithResponseStub        func(context.Context, client.PostgresPOSTInput, ...client.RequestEditorFn) (*client.CreatePostgresResponse, error)
	createPostgresWithResponseMutex       sync.RWMutex
	createPostgresWithResponseArgsForCall []struct {
		arg1 context.Context
		arg2 client.PostgresPOSTInput
		arg3 []client.RequestEditorFn
	}
	createPostgresWithResponseReturns struct {
		result1 *client.CreatePostgresResponse
		result2 error
	}
	createPostgresWithResponseReturnsOnCall map[int]struct {
		result1 *client.CreatePostgresResponse
		result2 error
	}
	ListPostgresWithResponseStub        func(context.Context, *client.ListPostgresParams, ...client.RequestEditorFn) (*client.ListPostgresResponse, error)
	listPostgresWithResponseMutex       sync.RWMutex
	listPostgresWithResponseArgsForCall []struct {
		arg1 context.Context
		arg2 *client.ListPostgresParams
		arg3 []client.RequestEditorFn
	}
	listPostgresWithResponseReturns struct {
		result1 *client.ListPostgresResponse
		result2 error
	}
	listPostgresWithResponseReturnsOnCall map[int]struct {
		result1 *client.ListPostgresResponse
		result2 error
	}
	RestartPostgresStub        func(context.Context, string, ...client.RequestEditorFn) (*http.Response, error)
	restartPostgresMutex       sync.RWMutex
	restartPostgresArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 []client.RequestEditorFn
	}
	restartPostgresReturns struct {
		result1 *http.Response
		result2 error
	}
	restartPostgresReturnsOnCall map[int]struct {
		result1 *http.Response
		result2 error
	}
	RetrievePostgresConnectionInfoWithResponseStub        func(context.Context, string, ...client.RequestEditorFn) (*client.RetrievePostgresConnectionInfoResponse, error)
	retrievePostgresConnectionInfoWithResponseMutex       sync.RWMutex
	retrievePostgresConnectionInfoWithResponseArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 []client.RequestEditorFn
	}
	retrievePostgresConnectionInfoWithResponseReturns struct {
		result1 *client.RetrievePostgresConnectionInfoResponse
		result2 error
	}
	retrievePostgresConnectionInfoWithResponseReturnsOnCall map[int]struct {
		result1 *client.RetrievePostgresConnectionInfoResponse
		result2 error
	}
	RetrievePostgresWithResponseStub        func(context.Context, string, ...client.RequestEditorFn) (*client.RetrievePostgresResponse, error)
	retrievePostgresWithResponseMutex       sync.RWMutex
	retrievePostgresWithResponseArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 []client.RequestEditorFn
	}
	retrievePostgresWithResponseReturns struct {
		result1 *client.RetrievePostgresResponse
		result2 error
	}
	retrievePostgresWithResponseReturnsOnCall map[int]struct {
		result1 *client.RetrievePostgresResponse
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakePostgresRepoClient) CreatePostgresWithResponse(arg1 context.Context, arg2 client.PostgresPOSTInput, arg3 ...client.RequestEditorFn) (*client.CreatePostgresResponse, error) {
	fake.createPostgresWithResponseMutex.Lock()
	ret, specificReturn := fake.createPostgresWithResponseReturnsOnCall[len(fake.createPostgresWithResponseArgsForCall)]
	fake.createPostgresWithResponseArgsForCall = append(fake.createPostgresWithResponseArgsForCall, struct {
		arg1 context.Context
		arg2 client.PostgresPOSTInput
		arg3 []client.RequestEditorFn
	}{arg1, arg2, arg3})
	stub := fake.CreatePostgresWithResponseStub
	fakeReturns := fake.createPostgresWithResponseReturns
	fake.recordInvocation("CreatePostgresWithResponse", []interface{}{arg1, arg2, arg3})
	fake.createPostgresWithResponseMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePostgresRepoClient) CreatePostgresWithResponseCallCount() int {
	fake.createPostgresWithResponseMutex.RLock()
	defer fake.createPostgresWithResponseMutex.RUnlock()
	return len(fake.createPostgresWithResponseArgsForCall)
}

func (fake *FakePostgresRepoClient) CreatePostgresWithResponseCalls(stub func(context.Context, client.PostgresPOSTInput, ...client.RequestEditorFn) (*client.CreatePostgresResponse, error)) {
	fake.createPostgresWithResponseMutex.Lock()
	defer fake.createPostgresWithResponseMutex.Unlock()
	fake.CreatePostgresWithResponseStub = stub
}

func (fake *FakePostgresRepoClient) CreatePostgresWithResponseArgsForCall(i int) (context.Context, client.PostgresPOSTInput, []client.RequestEditorFn) {
	fake.createPostgresWithResponseMutex.RLock()
	defer fake.createPostgresWithResponseMutex.RUnlock()
	argsForCall := fake.createPostgresWithResponseArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakePostgresRepoClient) CreatePostgresWithResponseReturns(result1 *client.CreatePostgresResponse, result2 error) {
	fake.createPostgresWithResponseMutex.Lock()
	defer fake.createPostgresWithResponseMutex.Unlock()
	fake.CreatePostgresWithResponseStub = nil
	fake.createPostgresWithResponseReturns = struct {
		result1 *client.CreatePostgresResponse
		result2 error
	}{result1, result2}
}

func (fake *FakePostgresRepoClient) CreatePostgresWithResponseReturnsOnCall(i int, result1 *client.CreatePostgresResponse, result2 error) {
	fake.createPostgresWithResponseMutex.Lock()
	defer fake.createPostgresWithResponseMutex.Unlock()
	fake.CreatePostgresWithResponseStub = nil
	if fake.createPostgresWithResponseReturnsOnCall == nil {
		fake.createPostgresWithResponseReturnsOnCall = make(map[int]struct {
			result1 *client.CreatePostgresResponse
			result2 error
		})
	}
	fake.createPostgresWithResponseReturnsOnCall[i] = struct {
		result1 *client.CreatePostgresResponse
		result2 error
	}{result1, result2}
}

func (fake *FakePostgresRepoClient) ListPostgresWithResponse(arg1 context.Context, arg2 *client.ListPostgresParams, arg3 ...client.RequestEditorFn) (*client.ListPostgresResponse, error) {
	fake.listPostgresWithResponseMutex.Lock()
	ret, specificReturn := fake.listPostgresWithResponseReturnsOnCall[len(fake.listPostgresWithResponseArgsForCall)]
	fake.listPostgresWithResponseArgsForCall = append(fake.listPostgresWithResponseArgsForCall, struct {
		arg1 context.Context
		arg2 *client.ListPostgresParams
		arg3 []client.RequestEditorFn
	}{arg1, arg2, arg3})
	stub := fake.ListPostgresWithResponseStub
	fakeReturns := fake.listPostgresWithResponseReturns
	fake.recordInvocation("ListPostgresWithResponse", []interface{}{arg1, arg2, arg3})
	fake.listPostgresWithResponseMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePostgresRepoClient) ListPostgresWithResponseCallCount() int {
	fake.listPostgresWithResponseMutex.RLock()
	defer fake.listPostgresWithResponseMutex.RUnlock()
	return len(fake.listPostgresWithResponseArgsForCall)
}

func (fake *FakePostgresRepoClient) ListPostgresWithResponseCalls(stub func(context.Context, *client.ListPostgresParams, ...client.RequestEditorFn) (*client.ListPostgresResponse, error)) {
	fake.listPostgresWithResponseMutex.Lock()
	defer fake.listPostgresWithResponseMutex.Unlock()
	fake.ListPostgresWithResponseStub = stub
}

func (fake *FakePostgresRepoClient) ListPostgresWithResponseArgsForCall(i int) (context.Context, *client.ListPostgresParams, []client.RequestEditorFn) {
	fake.listPostgresWithResponseMutex.RLock()
	defer fake.listPostgresWithResponseMutex.RUnlock()
	argsForCall := fake.listPostgresWithResponseArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakePostgresRepoClient) ListPostgresWithResponseReturns(result1 *client.ListPostgresResponse, result2 error) {
	fake.listPostgresWithResponseMutex.Lock()
	defer fake.listPostgresWithResponseMutex.Unlock()
	fake.ListPostgresWithResponseStub = nil
	fake.listPostgresWithResponseReturns = struct {
		result1 *client.ListPostgresResponse
		result2 error
	}{result1, result2}
}

func (fake *FakePostgresRepoClient) ListPostgresWithResponseReturnsOnCall(i int, result1 *client.ListPostgresResponse, result2 error) {
	fake.listPostgresWithResponseMutex.Lock()
	defer fake.listPostgresWithResponseMutex.Unlock()
	fake.ListPostgresWithResponseStub = nil
	if fake.listPostgresWithResponseReturnsOnCall == nil {
		fake.listPostgresWithResponseReturnsOnCall = make(map[int]struct {
			result1 *client.ListPostgresResponse
			result2 error
		})
	}
	fake.listPostgresWithResponseReturnsOnCall[i] = struct {
		result1 *client.ListPostgresResponse
		result2 error
	}{result1, result2}
}

func (fake *FakePostgresRepoClient) RestartPostgres(arg1 context.Context, arg2 string, arg3 ...client.RequestEditorFn) (*http.Response, error) {
	fake.restartPostgresMutex.Lock()
	ret, specificReturn := fake.restartPostgresReturnsOnCall[len(fake.restartPostgresArgsForCall)]
	fake.restartPostgresArgsForCall = append(fake.restartPostgresArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 []client.RequestEditorFn
	}{arg1, arg2, arg3})
	stub := fake.RestartPostgresStub
	fakeReturns := fake.restartPostgresReturns
	fake.recordInvocation("RestartPostgres", []interface{}{arg1, arg2, arg3})
	fake.restartPostgresMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePostgresRepoClient) RestartPostgresCallCount() int {
	fake.restartPostgresMutex.RLock()
	defer fake.restartPostgresMutex.RUnlock()
	return len(fake.restartPostgresArgsForCall)
}

func (fake *FakePostgresRepoClient) RestartPostgresCalls(stub func(context.Context, string, ...client.RequestEditorFn) (*http.Response, error)) {
	fake.restartPostgresMutex.Lock()
	defer fake.restartPostgresMutex.Unlock()
	fake.RestartPostgresStub = stub
}

func (fake *FakePostgresRepoClient) RestartPostgresArgsForCall(i int) (context.Context, string, []client.RequestEditorFn) {
	fake.restartPostgresMutex.RLock()
	defer fake.restartPostgresMutex.RUnlock()
	argsForCall := fake.restartPostgresArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakePostgresRepoClient) RestartPostgresReturns(result1 *http.Response, result2 error) {
	fake.restartPostgresMutex.Lock()
	defer fake.restartPostgresMutex.Unlock()
	fake.RestartPostgresStub = nil
	fake.restartPostgresReturns = struct {
		result1 *http.Response
		result2 error
	}{result1, result2}
}

func (fake *FakePostgresRepoClient) RestartPostgresReturnsOnCall(i int, result1 *http.Response, result2 error) {
	fake.restartPostgresMutex.Lock()
	defer fake.restartPostgresMutex.Unlock()
	fake.RestartPostgresStub = nil
	if fake.restartPostgresReturnsOnCall == nil {
		fake.restartPostgresReturnsOnCall = make(map[int]struct {
			result1 *http.Response
			result2 error
		})
	}
	fake.restartPostgresReturnsOnCall[i] = struct {
		result1 *http.Response
		result2 error
	}{result1, result2}
}

func (fake *FakePostgresRepoClient) RetrievePostgresConnectionInfoWithResponse(arg1 context.Context, arg2 string, arg3 ...client.RequestEditorFn) (*client.RetrievePostgresConnectionInfoResponse, error) {
	fake.retrievePostgresConnectionInfoWithResponseMutex.Lock()
	ret, specificReturn := fake.retrievePostgresConnectionInfoWithResponseReturnsOnCall[len(fake.retrievePostgresConnectionInfoWithResponseArgsForCall)]
	fake.retrievePostgresConnectionInfoWithResponseArgsForCall = append(fake.retrievePostgresConnectionInfoWithResponseArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 []client.RequestEditorFn
	}{arg1, arg2, arg3})
	stub := fake.RetrievePostgresConnectionInfoWithResponseStub
	fakeReturns := fake.retrievePostgresConnectionInfoWithResponseReturns
	fake.recordInvocation("RetrievePostgresConnectionInfoWithResponse", []interface{}{arg1, arg2, arg3})
	fake.retrievePostgresConnectionInfoWithResponseMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePostgresRepoClient) RetrievePostgresConnectionInfoWithResponseCallCount() int {
	fake.retrievePostgresConnectionInfoWithResponseMutex.RLock()
	defer fake.retrievePostgresConnectionInfoWithResponseMutex.RUnlock()
	return len(fake.retrievePostgresConnectionInfoWithResponseArgsForCall)
}

func (fake *FakePostgresRepoClient) RetrievePostgresConnectionInfoWithResponseCalls(stub func(context.Context, string, ...client.RequestEditorFn) (*client.RetrievePostgresConnectionInfoResponse, error)) {
	fake.retrievePostgresConnectionInfoWithResponseMutex.Lock()
	defer fake.retrievePostgresConnectionInfoWithResponseMutex.Unlock()
	fake.RetrievePostgresConnectionInfoWithResponseStub = stub
}

func (fake *FakePostgresRepoClient) RetrievePostgresConnectionInfoWithResponseArgsForCall(i int) (context.Context, string, []client.RequestEditorFn) {
	fake.retrievePostgresConnectionInfoWithResponseMutex.RLock()
	defer fake.retrievePostgresConnectionInfoWithResponseMutex.RUnlock()
	argsForCall := fake.retrievePostgresConnectionInfoWithResponseArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakePostgresRepoClient) RetrievePostgresConnectionInfoWithResponseReturns(result1 *client.RetrievePostgresConnectionInfoResponse, result2 error) {
	fake.retrievePostgresConnectionInfoWithResponseMutex.Lock()
	defer fake.retrievePostgresConnectionInfoWithResponseMutex.Unlock()
	fake.RetrievePostgresConnectionInfoWithResponseStub = nil
	fake.retrievePostgresConnectionInfoWithResponseReturns = struct {
		result1 *client.RetrievePostgresConnectionInfoResponse
		result2 error
	}{result1, result2}
}

func (fake *FakePostgresRepoClient) RetrievePostgresConnectionInfoWithResponseReturnsOnCall(i int, result1 *client.RetrievePostgresConnectionInfoResponse, result2 error) {
	fake.retrievePostgresConnectionInfoWithResponseMutex.Lock()
	defer fake.retrievePostgresConnectionInfoWithResponseMutex.Unlock()
	fake.RetrievePostgresConnectionInfoWithResponseStub = nil
	if fake.retrievePostgresConnectionInfoWithResponseReturnsOnCall == nil {
		fake.retrievePostgresConnectionInfoWithResponseReturnsOnCall = make(map[int]struct {
			result1 *client.RetrievePostgresConnectionInfoResponse
			result2 error
		})
	}
	fake.retrievePostgresConnectionInfoWithResponseReturnsOnCall[i] = struct {
		result1 *client.RetrievePostgresConnectionInfoResponse
		result2 error
	}{result1, result2}
}

func (fake *FakePostgresRepoClient) RetrievePostgresWithResponse(arg1 context.Context, arg2 string, arg3 ...client.RequestEditorFn) (*client.RetrievePostgresResponse, error) {
	fake.retrievePostgresWithResponseMutex.Lock()
	ret, specificReturn := fake.retrievePostgresWithResponseReturnsOnCall[len(fake.retrievePostgresWithResponseArgsForCall)]
	fake.retrievePostgresWithResponseArgsForCall = append(fake.retrievePostgresWithResponseArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 []client.RequestEditorFn
	}{arg1, arg2, arg3})
	stub := fake.RetrievePostgresWithResponseStub
	fakeReturns := fake.retrievePostgresWithResponseReturns
	fake.recordInvocation("RetrievePostgresWithResponse", []interface{}{arg1, arg2, arg3})
	fake.retrievePostgresWithResponseMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePostgresRepoClient) RetrievePostgresWithResponseCallCount() int {
	fake.retrievePostgresWithResponseMutex.RLock()
	defer fake.retrievePostgresWithResponseMutex.RUnlock()
	return len(fake.retrievePostgresWithResponseArgsForCall)
}

func (fake *FakePostgresRepoClient) RetrievePostgresWithResponseCalls(stub func(context.Context, string, ...client.RequestEditorFn) (*client.RetrievePostgresResponse, error)) {
	fake.retrievePostgresWithResponseMutex.Lock()
	defer fake.retrievePostgresWithResponseMutex.Unlock()
	fake.RetrievePostgresWithResponseStub = stub
}

func (fake *FakePostgresRepoClient) RetrievePostgresWithResponseArgsForCall(i int) (context.Context, string, []client.RequestEditorFn) {
	fake.retrievePostgresWithResponseMutex.RLock()
	defer fake.retrievePostgresWithResponseMutex.RUnlock()
	argsForCall := fake.retrievePostgresWithResponseArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakePostgresRepoClient) RetrievePostgresWithResponseReturns(result1 *client.RetrievePostgresResponse, result2 error) {
	fake.retrievePostgresWithResponseMutex.Lock()
	defer fake.retrievePostgresWithResponseMutex.Unlock()
	fake.RetrievePostgresWithResponseStub = nil
	fake.retrievePostgresWithResponseReturns = struct {
		result1 *client.RetrievePostgresResponse
		result2 error
	}{result1, result2}
}

func (fake *FakePostgresRepoClient) RetrievePostgresWithResponseReturnsOnCall(i int, result1 *client.RetrievePostgresResponse, result2 error) {
	fake.retrievePostgresWithResponseMutex.Lock()
	defer fake.retrievePostgresWithResponseMutex.Unlock()
	fake.RetrievePostgresWithResponseStub = nil
	if fake.retrievePostgresWithResponseReturnsOnCall == nil {
		fake.retrievePostgresWithResponseReturnsOnCall = make(map[int]struct {
			result1 *client.RetrievePostgresResponse
			result2 error
		})
	}
	fake.retrievePostgresWithResponseReturnsOnCall[i] = struct {
		result1 *client.RetrievePostgresResponse
		result2 error
	}{result1, result2}
}

func (fake *FakePostgresRepoClient) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.createPostgresWithResponseMutex.RLock()
	defer fake.createPostgresWithResponseMutex.RUnlock()
	fake.listPostgresWithResponseMutex.RLock()
	defer fake.listPostgresWithResponseMutex.RUnlock()
	fake.restartPostgresMutex.RLock()
	defer fake.restartPostgresMutex.RUnlock()
	fake.retrievePostgresConnectionInfoWithResponseMutex.RLock()
	defer fake.retrievePostgresConnectionInfoWithResponseMutex.RUnlock()
	fake.retrievePostgresWithResponseMutex.RLock()
	defer fake.retrievePostgresWithResponseMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakePostgresRepoClient) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}
